<!DOCTYPE html>
<html lang="en-gb">

<head>
  <title>TractoR ~ Connectivity graphs</title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="author" content="Jon Clayden">
  <meta name="keywords" content="TractoR,MRI,imaging,tractography,graph,software,open-source">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  
  <link href="https://fonts.googleapis.com/css?family=Roboto%7CSource+Code+Pro" rel="stylesheet">
  <link href="assets/prism.css" rel="stylesheet">
  <link href="assets/style.css" rel="stylesheet">
  
  
</head>

<body>

<header>
  <div id="banner">
    <a href="home.html"><img id="logo" src="assets/logo.svg" alt="TractoR logo"></a>
  </div>
</header>

<div id="navbar">
  <nav>
    <div id="links">
      <span><a href="home.html">Home</a></span>
      <span><a href="home.html#site-contents">Contents</a></span>
      <span><a href="install.html">Installation</a></span>
      <span><a href="changelog.html">Changelog</a></span>
      <span><a href="references.html">References</a></span>
      <span><a href="https://twitter.com/tracto_r">Twitter</a></span>
      <span><a rel="me" href="https://fosstodon.org/@tractor">Mastodon</a></span>
    </div>
  </nav>
</div>

<div id="main" class="language-bash">


<h1>Connectivity graphs</h1>

<p>This page discusses TractoR’s facilities for creating, manipulating and visualising abstract graphs representing brain connectivity. Some <a href="structural.html">parcellated structural data</a> is a prerequisite.</p>

<h2 id="creating-a-graph-diffusion">Creating a graph (diffusion)</h2>

<p>Using <a href="diffusion-processing.html">diffusion-weighted data</a> and tractography, a graph can be created which represents streamline-based connectivity between regions of interest. The general principle is to seed within regions of interest, or across the whole brain; identify sets of streamlines which connect pairs of anatomical regions; and then (optionally) to use properties of these streamlines to derive a quantitative measure of region-to-region connectivity. In TractoR, these three tasks would usually be performed by the <code>track</code>, <code>graph-build</code> and <code>graph-reweight</code> scripts.</p>

<p>To generate a set of streamlines, each of which passes through at least two target regions of interest, we can use the <code>track</code> script. For example,</p>

<pre><code class="language-bash">tractor track /data/subject1 white_matter TargetRegions:cerebral_cortex TerminateAtTargets:true MinTargetHits:2 Streamlines:100x RequireMap:false RequirePaths:true
</code></pre>

<p>In this case we seed 100 streamlines from every voxel labelled as white matter in the parcellation. In this case the target regions are all areas identified as cerebral cortex in the <a href="structural.html">parcellation lookup table</a>. Other targets, such as subcortical grey matter, can also be included by adding region names or region types to the <code>TargetRegions</code> option.</p>

<p>A set of streamlines is generated by this script—as long as <code>RequirePaths:true</code> is given—and, by default, written into the file “tract.trk”. An <a href="conventions.html#file-types">auxiliary file</a>, “tract.trkl”, is also created to store information about target hits for each streamline. These can then be used to create a graph using a command like</p>

<pre><code class="language-bash">tractor graph-build /data/subject1 TractName:tract TargetRegions:cerebral_cortex GraphName:diffusion_graph
</code></pre>

<p>The “TargetRegions” and “TractName” options should match what were used for <code>track</code>.</p>

<p>At this point you have a binary graph in which an edge exists between each pair of regions connected by at least one streamline. Each edge has attributes like the average voxelwise FA along the streamlines or the number of streamlines constituting the connection, and vertices have attributes such as their volume. These can be used to assign weights to the edges if required. For example,</p>

<pre><code class="language-bash">tractor graph-reweight diffusion_graph nStreamlines
</code></pre>

<p>will use the number of streamlines as the weight of the connection. Vertex attributes can also be used, but since there are two such values for each connection, you need to decide how to merge them. For example,</p>

<pre><code class="language-bash">tractor graph-reweight diffusion_graph "nStreamlines/voxelCount" VertexAttributes:mean
</code></pre>

<p>will average the two vertex attributes for each edge, and then use the number of streamlines divided by the average voxel count in the two target regions as the weight.</p>

<h2 id="creating-a-graph-bold-fmri">Creating a graph (BOLD fMRI)</h2>

<p>Resting-state fMRI data may be used to establish functional connectivity, or the degree of correlation in activity between spatially separated cortical areas. Although TractoR does not currently provide scripts for preprocessing functional data—<a href="http://www.fil.ion.ucl.ac.uk/spm/">SPM</a> and <a href="http://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FEAT">FSL-FEAT</a> are two well-known software tools that could be used for this purpose—it does allow already preprocessed data to be imported and used to create functional connectivity graphs.</p>

<p>To get the data into a session directory, the <code>import</code> script can be used:</p>

<pre><code class="language-bash">tractor import /data/subject1 fmri.nii.gz ImageWeighting:functional
</code></pre>

<p>Creating a functional connectivity graph then requires three stages, namely</p>

<ol>
<li>propagating a cortical parcellation from structural to functional space;</li>
<li>identifying a representative signal trace for each parcellated region of interest; and</li>
<li>calculating covariance measures between each pair of regional traces.</li>
</ol>

<p>The <code>graph-build</code> script can be used to perform these tasks. Stage 1, the transformation, is performed implicitly. Stage 2 is controlled by the “RegionTimeSeries” option, which may be “mean” for the mean of the voxelwise time series, or “pc” for the first principal component, which will capture more of the variance within the region but is less standard. At the third stage, several measures of association are calculated, but if the number of time points is modest it can be useful to employ a “shrinkage” approach that TractoR offers (via the <a href="http://strimmerlab.org/software/corpcor/"><code>corpcor</code> R package</a>), which regularises the estimates. For example,</p>

<pre><code class="language-bash">tractor graph-build /data/subject1 Type:functional UseShrinkage:true GraphName:functional_graph
</code></pre>

<p>The resulting binary graph than then be weighted by correlation, say, by using the command</p>

<pre><code class="language-bash">tractor graph-reweight functional_graph correlation
</code></pre>

<h2 id="graph-properties">Graph properties</h2>

<p>The basic properties of a graph object can be obtained using the generic <code>peek</code> script, viz.</p>

<pre><code class="language-bash">tractor peek graph.Rdata
</code></pre>

<p>However additional graph-theoretical metrics can be calculated and displayed using the <code>graph-props</code> script:</p>

<pre><code class="language-bash">tractor graph-props graph.Rdata
</code></pre>

<p>By default, the latter script will binarise the graph and report binary versions of the various metrics. It will also ignore any vertices which are not connected to any others, excluding them from all calculations. However, there are a number of options to control whether or not the graph is binarised and at what edge weight threshold, how to handle negative weights and disconnected vertices, and whether to renormalise the edge weights. See <code>tractor -o graph-props</code> for details.</p>

<h2 id="graph-visualisation">Graph visualisation</h2>

<p>The <code>graph-viz</code> script can be used to visualise graphs, either as an association matrix or in traditional topological form.</p>

<pre><code class="language-bash">tractor graph-viz graph MatrixView:true WeightLimits:0,0.1
</code></pre>

<p><img src="graph-matrix.png" alt="Graph shown as association matrix"></p>

<pre><code class="language-bash">tractor graph-viz graph MatrixView:false UseLocations:true ShowBrain:true WeightLimits:0,0.1
</code></pre>

<p><img src="graph-brain.png" alt="Graph shown topologically on brain"></p>

<h2 id="graph-decomposition">Graph decomposition</h2>

<p>For many applications you may be interested subnetworks within the overall brain graph, rather than the entire graph as a whole. You could determine these subnetworks by hand, but TractoR also provides some data-driven approaches to factoring or partitioning a graph into parts. The techniques currently offered are <a href="http://dx.doi.org/10.1371/journal.pone.0060997">principal network analysis</a> and a <a href="http://dx.doi.org/10.1073/pnas.0601602103">modularity maximisation</a> partitioning algorithm. Both of these are accessible through the <code>graph-decompose</code> script. For example,</p>

<pre><code class="language-bash">tractor graph-decompose graph Method:principal-networks EdgeWeightThreshold:0.2
</code></pre>

<p>The principal networks approach uses a matrix factoring approach akin to principal component analysis, while modularity maximisation tries to separate the graph into subnetworks whose overall <a href="https://en.wikipedia.org/wiki/Modularity_(networks)">modularity</a> is maximised. These and other approaches to graph decomposition, their strengths and weaknesses, are discussed in the <a href="http://dx.doi.org/10.1371/journal.pone.0060997">principal networks paper</a>. Either way, the results are files called “graph_partitioned.Rdata”, which contains a version of the original graph with additional information on the final partition, and “graph_decomposed.Rdata”, which contains a series of smaller graphs. This file can be split into its parts using the <code>split</code> script, viz.</p>

<pre><code class="language-bash">tractor split graph_decomposed.Rdata
</code></pre>

<p>The individual graphs can then be visualised, or their graph properties calculated, as needed.</p>


</div>

<script async src="assets/prism.js"></script>

</body>

</html>
